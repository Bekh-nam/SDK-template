import { Signer, EventFilter, BigNumber, BigNumberish, PopulatedTransaction, ethers, providers } from 'ethers';
import { Contract, CallOverrides, Overrides, ContractTransaction, PayableOverrides } from '@ethersproject/contracts';
import { BytesLike } from '@ethersproject/bytes';
import { Provider, Listener } from '@ethersproject/providers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';

/* Autogenerated file. Do not edit manually. */


interface PredictionCollateralInterface extends ethers.utils.Interface {
	functions: {
		"INVERSE_BASIS_POINT()": FunctionFragment;
		"MAX_CREATOR_FEE()": FunctionFragment;
		"SERVICE_FEE()": FunctionFragment;
		"additionalRewardEvent(uint256,uint256)": FunctionFragment;
		"cancelEvent(uint256)": FunctionFragment;
		"createEvent(string,string[],address,uint256,uint256,uint256,uint256)": FunctionFragment;
		"entranceFee()": FunctionFragment;
		"eventDetail(uint256)": FunctionFragment;
		"extraReward(address)": FunctionFragment;
		"feeRecipient()": FunctionFragment;
		"metaspacecyAccessControls()": FunctionFragment;
		"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": FunctionFragment;
		"onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
		"pause()": FunctionFragment;
		"paused()": FunctionFragment;
		"predictEvent(uint256,uint256,uint256)": FunctionFragment;
		"proofTokens()": FunctionFragment;
		"redeemEvent(uint256,uint256,uint256)": FunctionFragment;
		"resolveEvent(uint256,uint256[])": FunctionFragment;
		"supportsInterface(bytes4)": FunctionFragment;
		"totalEvent()": FunctionFragment;
		"unpause()": FunctionFragment;
		"updateEntranceFee(uint256)": FunctionFragment;
		"updateFeeRecipient(address)": FunctionFragment;
	};

	encodeFunctionData(functionFragment: "INVERSE_BASIS_POINT", values?: undefined): string;
	encodeFunctionData(functionFragment: "MAX_CREATOR_FEE", values?: undefined): string;
	encodeFunctionData(functionFragment: "SERVICE_FEE", values?: undefined): string;
	encodeFunctionData(functionFragment: "additionalRewardEvent", values: [BigNumberish, BigNumberish]): string;
	encodeFunctionData(functionFragment: "cancelEvent", values: [BigNumberish]): string;
	encodeFunctionData(functionFragment: "createEvent", values: [string, string[], string, BigNumberish, BigNumberish, BigNumberish, BigNumberish]): string;
	encodeFunctionData(functionFragment: "entranceFee", values?: undefined): string;
	encodeFunctionData(functionFragment: "eventDetail", values: [BigNumberish]): string;
	encodeFunctionData(functionFragment: "extraReward", values: [string]): string;
	encodeFunctionData(functionFragment: "feeRecipient", values?: undefined): string;
	encodeFunctionData(functionFragment: "metaspacecyAccessControls", values?: undefined): string;
	encodeFunctionData(functionFragment: "onERC1155BatchReceived", values: [string, string, BigNumberish[], BigNumberish[], BytesLike]): string;
	encodeFunctionData(functionFragment: "onERC1155Received", values: [string, string, BigNumberish, BigNumberish, BytesLike]): string;
	encodeFunctionData(functionFragment: "pause", values?: undefined): string;
	encodeFunctionData(functionFragment: "paused", values?: undefined): string;
	encodeFunctionData(functionFragment: "predictEvent", values: [BigNumberish, BigNumberish, BigNumberish]): string;
	encodeFunctionData(functionFragment: "proofTokens", values?: undefined): string;
	encodeFunctionData(functionFragment: "redeemEvent", values: [BigNumberish, BigNumberish, BigNumberish]): string;
	encodeFunctionData(functionFragment: "resolveEvent", values: [BigNumberish, BigNumberish[]]): string;
	encodeFunctionData(functionFragment: "supportsInterface", values: [BytesLike]): string;
	encodeFunctionData(functionFragment: "totalEvent", values?: undefined): string;
	encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
	encodeFunctionData(functionFragment: "updateEntranceFee", values: [BigNumberish]): string;
	encodeFunctionData(functionFragment: "updateFeeRecipient", values: [string]): string;

	decodeFunctionResult(functionFragment: "INVERSE_BASIS_POINT", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "MAX_CREATOR_FEE", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "SERVICE_FEE", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "additionalRewardEvent", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "cancelEvent", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "createEvent", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "entranceFee", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "eventDetail", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "extraReward", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "feeRecipient", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "metaspacecyAccessControls", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "onERC1155BatchReceived", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "onERC1155Received", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "predictEvent", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "proofTokens", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "redeemEvent", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "resolveEvent", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "supportsInterface", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "totalEvent", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "updateEntranceFee", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "updateFeeRecipient", data: BytesLike): Result;

	events: {
		"AdditionalRewardEvent(uint256,uint256)": EventFragment;
		"CancelEvent(address,uint256)": EventFragment;
		"CreatedEvent(uint256,address,string,string[],address,uint256,uint256,uint256,uint256)": EventFragment;
		"Paused(address)": EventFragment;
		"PredictedEvent(address,uint256,uint256,uint256)": EventFragment;
		"RedeemEvent(address,uint256,uint256,uint256)": EventFragment;
		"ResolvedEvent(uint256,address,uint256[],uint256)": EventFragment;
		"Unpaused(address)": EventFragment;
	};

	getEvent(nameOrSignatureOrTopic: "AdditionalRewardEvent"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "CancelEvent"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "CreatedEvent"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "PredictedEvent"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "RedeemEvent"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "ResolvedEvent"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
}

declare class PredictionCollateral extends Contract {
	connect(signerOrProvider: Signer | Provider | string): this;
	attach(addressOrName: string): this;
	deployed(): Promise<this>;

	on(event: EventFilter | string, listener: Listener): this;
	once(event: EventFilter | string, listener: Listener): this;
	addListener(eventName: EventFilter | string, listener: Listener): this;
	removeAllListeners(eventName: EventFilter | string): this;
	removeListener(eventName: any, listener: Listener): this;

	interface: PredictionCollateralInterface;

	functions: {
		INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<[BigNumber]>;

		"INVERSE_BASIS_POINT()"(overrides?: CallOverrides): Promise<[BigNumber]>;

		MAX_CREATOR_FEE(overrides?: CallOverrides): Promise<[BigNumber]>;

		"MAX_CREATOR_FEE()"(overrides?: CallOverrides): Promise<[BigNumber]>;

		SERVICE_FEE(overrides?: CallOverrides): Promise<[BigNumber]>;

		"SERVICE_FEE()"(overrides?: CallOverrides): Promise<[BigNumber]>;

		additionalRewardEvent(_eventId: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

		"additionalRewardEvent(uint256,uint256)"(_eventId: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

		cancelEvent(_eventId: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

		"cancelEvent(uint256)"(_eventId: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

		createEvent(
			_description: string,
			_answers: string[],
			_payment: string,
			_creatorFee: BigNumberish,
			_startTime: BigNumberish,
			_endTime: BigNumberish,
			_extraTime: BigNumberish,
			overrides?: PayableOverrides
		): Promise<ContractTransaction>;

		"createEvent(string,string[],address,uint256,uint256,uint256,uint256)"(
			_description: string,
			_answers: string[],
			_payment: string,
			_creatorFee: BigNumberish,
			_startTime: BigNumberish,
			_endTime: BigNumberish,
			_extraTime: BigNumberish,
			overrides?: PayableOverrides
		): Promise<ContractTransaction>;

		entranceFee(overrides?: CallOverrides): Promise<[BigNumber]>;

		"entranceFee()"(overrides?: CallOverrides): Promise<[BigNumber]>;

		eventDetail(
			_eventId: BigNumberish,
			overrides?: CallOverrides
		): Promise<
			[
				[string, string[], string, string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber[]] & {
					description: string;
					answers: string[];
					creator: string;
					payment: string;
					reward: BigNumber;
					creatorFee: BigNumber;
					startTime: BigNumber;
					endTime: BigNumber;
					extraTime: BigNumber;
					outcomes: BigNumber[];
				}
			] & {
				_event: [string, string[], string, string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber[]] & {
					description: string;
					answers: string[];
					creator: string;
					payment: string;
					reward: BigNumber;
					creatorFee: BigNumber;
					startTime: BigNumber;
					endTime: BigNumber;
					extraTime: BigNumber;
					outcomes: BigNumber[];
				};
			}
		>;

		"eventDetail(uint256)"(
			_eventId: BigNumberish,
			overrides?: CallOverrides
		): Promise<
			[
				[string, string[], string, string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber[]] & {
					description: string;
					answers: string[];
					creator: string;
					payment: string;
					reward: BigNumber;
					creatorFee: BigNumber;
					startTime: BigNumber;
					endTime: BigNumber;
					extraTime: BigNumber;
					outcomes: BigNumber[];
				}
			] & {
				_event: [string, string[], string, string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber[]] & {
					description: string;
					answers: string[];
					creator: string;
					payment: string;
					reward: BigNumber;
					creatorFee: BigNumber;
					startTime: BigNumber;
					endTime: BigNumber;
					extraTime: BigNumber;
					outcomes: BigNumber[];
				};
			}
		>;

		extraReward(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

		"extraReward(address)"(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

		feeRecipient(overrides?: CallOverrides): Promise<[string]>;

		"feeRecipient()"(overrides?: CallOverrides): Promise<[string]>;

		metaspacecyAccessControls(overrides?: CallOverrides): Promise<[string]>;

		"metaspacecyAccessControls()"(overrides?: CallOverrides): Promise<[string]>;

		onERC1155BatchReceived(arg0: string, arg1: string, arg2: BigNumberish[], arg3: BigNumberish[], arg4: BytesLike, overrides?: Overrides): Promise<ContractTransaction>;

		"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
			arg0: string,
			arg1: string,
			arg2: BigNumberish[],
			arg3: BigNumberish[],
			arg4: BytesLike,
			overrides?: Overrides
		): Promise<ContractTransaction>;

		onERC1155Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, overrides?: Overrides): Promise<ContractTransaction>;

		"onERC1155Received(address,address,uint256,uint256,bytes)"(
			arg0: string,
			arg1: string,
			arg2: BigNumberish,
			arg3: BigNumberish,
			arg4: BytesLike,
			overrides?: Overrides
		): Promise<ContractTransaction>;

		pause(overrides?: Overrides): Promise<ContractTransaction>;

		"pause()"(overrides?: Overrides): Promise<ContractTransaction>;

		paused(overrides?: CallOverrides): Promise<[boolean]>;

		"paused()"(overrides?: CallOverrides): Promise<[boolean]>;

		predictEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: PayableOverrides): Promise<ContractTransaction>;

		"predictEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: PayableOverrides): Promise<ContractTransaction>;

		proofTokens(overrides?: CallOverrides): Promise<[string]>;

		"proofTokens()"(overrides?: CallOverrides): Promise<[string]>;

		redeemEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

		"redeemEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

		resolveEvent(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: Overrides): Promise<ContractTransaction>;

		"resolveEvent(uint256,uint256[])"(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: Overrides): Promise<ContractTransaction>;

		supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;

		"supportsInterface(bytes4)"(interfaceId: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;

		totalEvent(overrides?: CallOverrides): Promise<[BigNumber] & { total: BigNumber }>;

		"totalEvent()"(overrides?: CallOverrides): Promise<[BigNumber] & { total: BigNumber }>;

		unpause(overrides?: Overrides): Promise<ContractTransaction>;

		"unpause()"(overrides?: Overrides): Promise<ContractTransaction>;

		updateEntranceFee(_amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

		"updateEntranceFee(uint256)"(_amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

		updateFeeRecipient(_recepient: string, overrides?: Overrides): Promise<ContractTransaction>;

		"updateFeeRecipient(address)"(_recepient: string, overrides?: Overrides): Promise<ContractTransaction>;
	};

	INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

	"INVERSE_BASIS_POINT()"(overrides?: CallOverrides): Promise<BigNumber>;

	MAX_CREATOR_FEE(overrides?: CallOverrides): Promise<BigNumber>;

	"MAX_CREATOR_FEE()"(overrides?: CallOverrides): Promise<BigNumber>;

	SERVICE_FEE(overrides?: CallOverrides): Promise<BigNumber>;

	"SERVICE_FEE()"(overrides?: CallOverrides): Promise<BigNumber>;

	additionalRewardEvent(_eventId: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

	"additionalRewardEvent(uint256,uint256)"(_eventId: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

	cancelEvent(_eventId: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

	"cancelEvent(uint256)"(_eventId: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

	createEvent(
		_description: string,
		_answers: string[],
		_payment: string,
		_creatorFee: BigNumberish,
		_startTime: BigNumberish,
		_endTime: BigNumberish,
		_extraTime: BigNumberish,
		overrides?: PayableOverrides
	): Promise<ContractTransaction>;

	"createEvent(string,string[],address,uint256,uint256,uint256,uint256)"(
		_description: string,
		_answers: string[],
		_payment: string,
		_creatorFee: BigNumberish,
		_startTime: BigNumberish,
		_endTime: BigNumberish,
		_extraTime: BigNumberish,
		overrides?: PayableOverrides
	): Promise<ContractTransaction>;

	entranceFee(overrides?: CallOverrides): Promise<BigNumber>;

	"entranceFee()"(overrides?: CallOverrides): Promise<BigNumber>;

	eventDetail(
		_eventId: BigNumberish,
		overrides?: CallOverrides
	): Promise<
		[string, string[], string, string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber[]] & {
			description: string;
			answers: string[];
			creator: string;
			payment: string;
			reward: BigNumber;
			creatorFee: BigNumber;
			startTime: BigNumber;
			endTime: BigNumber;
			extraTime: BigNumber;
			outcomes: BigNumber[];
		}
	>;

	"eventDetail(uint256)"(
		_eventId: BigNumberish,
		overrides?: CallOverrides
	): Promise<
		[string, string[], string, string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber[]] & {
			description: string;
			answers: string[];
			creator: string;
			payment: string;
			reward: BigNumber;
			creatorFee: BigNumber;
			startTime: BigNumber;
			endTime: BigNumber;
			extraTime: BigNumber;
			outcomes: BigNumber[];
		}
	>;

	extraReward(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

	"extraReward(address)"(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

	feeRecipient(overrides?: CallOverrides): Promise<string>;

	"feeRecipient()"(overrides?: CallOverrides): Promise<string>;

	metaspacecyAccessControls(overrides?: CallOverrides): Promise<string>;

	"metaspacecyAccessControls()"(overrides?: CallOverrides): Promise<string>;

	onERC1155BatchReceived(arg0: string, arg1: string, arg2: BigNumberish[], arg3: BigNumberish[], arg4: BytesLike, overrides?: Overrides): Promise<ContractTransaction>;

	"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
		arg0: string,
		arg1: string,
		arg2: BigNumberish[],
		arg3: BigNumberish[],
		arg4: BytesLike,
		overrides?: Overrides
	): Promise<ContractTransaction>;

	onERC1155Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, overrides?: Overrides): Promise<ContractTransaction>;

	"onERC1155Received(address,address,uint256,uint256,bytes)"(arg0: string, arg1: string, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, overrides?: Overrides): Promise<ContractTransaction>;

	pause(overrides?: Overrides): Promise<ContractTransaction>;

	"pause()"(overrides?: Overrides): Promise<ContractTransaction>;

	paused(overrides?: CallOverrides): Promise<boolean>;

	"paused()"(overrides?: CallOverrides): Promise<boolean>;

	predictEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: PayableOverrides): Promise<ContractTransaction>;

	"predictEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: PayableOverrides): Promise<ContractTransaction>;

	proofTokens(overrides?: CallOverrides): Promise<string>;

	"proofTokens()"(overrides?: CallOverrides): Promise<string>;

	redeemEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

	"redeemEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

	resolveEvent(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: Overrides): Promise<ContractTransaction>;

	"resolveEvent(uint256,uint256[])"(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: Overrides): Promise<ContractTransaction>;

	supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;

	"supportsInterface(bytes4)"(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;

	totalEvent(overrides?: CallOverrides): Promise<BigNumber>;

	"totalEvent()"(overrides?: CallOverrides): Promise<BigNumber>;

	unpause(overrides?: Overrides): Promise<ContractTransaction>;

	"unpause()"(overrides?: Overrides): Promise<ContractTransaction>;

	updateEntranceFee(_amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

	"updateEntranceFee(uint256)"(_amount: BigNumberish, overrides?: Overrides): Promise<ContractTransaction>;

	updateFeeRecipient(_recepient: string, overrides?: Overrides): Promise<ContractTransaction>;

	"updateFeeRecipient(address)"(_recepient: string, overrides?: Overrides): Promise<ContractTransaction>;

	callStatic: {
		INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

		"INVERSE_BASIS_POINT()"(overrides?: CallOverrides): Promise<BigNumber>;

		MAX_CREATOR_FEE(overrides?: CallOverrides): Promise<BigNumber>;

		"MAX_CREATOR_FEE()"(overrides?: CallOverrides): Promise<BigNumber>;

		SERVICE_FEE(overrides?: CallOverrides): Promise<BigNumber>;

		"SERVICE_FEE()"(overrides?: CallOverrides): Promise<BigNumber>;

		additionalRewardEvent(_eventId: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

		"additionalRewardEvent(uint256,uint256)"(_eventId: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

		cancelEvent(_eventId: BigNumberish, overrides?: CallOverrides): Promise<void>;

		"cancelEvent(uint256)"(_eventId: BigNumberish, overrides?: CallOverrides): Promise<void>;

		createEvent(
			_description: string,
			_answers: string[],
			_payment: string,
			_creatorFee: BigNumberish,
			_startTime: BigNumberish,
			_endTime: BigNumberish,
			_extraTime: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		"createEvent(string,string[],address,uint256,uint256,uint256,uint256)"(
			_description: string,
			_answers: string[],
			_payment: string,
			_creatorFee: BigNumberish,
			_startTime: BigNumberish,
			_endTime: BigNumberish,
			_extraTime: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		entranceFee(overrides?: CallOverrides): Promise<BigNumber>;

		"entranceFee()"(overrides?: CallOverrides): Promise<BigNumber>;

		eventDetail(
			_eventId: BigNumberish,
			overrides?: CallOverrides
		): Promise<
			[string, string[], string, string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber[]] & {
				description: string;
				answers: string[];
				creator: string;
				payment: string;
				reward: BigNumber;
				creatorFee: BigNumber;
				startTime: BigNumber;
				endTime: BigNumber;
				extraTime: BigNumber;
				outcomes: BigNumber[];
			}
		>;

		"eventDetail(uint256)"(
			_eventId: BigNumberish,
			overrides?: CallOverrides
		): Promise<
			[string, string[], string, string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber[]] & {
				description: string;
				answers: string[];
				creator: string;
				payment: string;
				reward: BigNumber;
				creatorFee: BigNumber;
				startTime: BigNumber;
				endTime: BigNumber;
				extraTime: BigNumber;
				outcomes: BigNumber[];
			}
		>;

		extraReward(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

		"extraReward(address)"(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

		feeRecipient(overrides?: CallOverrides): Promise<string>;

		"feeRecipient()"(overrides?: CallOverrides): Promise<string>;

		metaspacecyAccessControls(overrides?: CallOverrides): Promise<string>;

		"metaspacecyAccessControls()"(overrides?: CallOverrides): Promise<string>;

		onERC1155BatchReceived(arg0: string, arg1: string, arg2: BigNumberish[], arg3: BigNumberish[], arg4: BytesLike, overrides?: CallOverrides): Promise<string>;

		"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
			arg0: string,
			arg1: string,
			arg2: BigNumberish[],
			arg3: BigNumberish[],
			arg4: BytesLike,
			overrides?: CallOverrides
		): Promise<string>;

		onERC1155Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, overrides?: CallOverrides): Promise<string>;

		"onERC1155Received(address,address,uint256,uint256,bytes)"(arg0: string, arg1: string, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, overrides?: CallOverrides): Promise<string>;

		pause(overrides?: CallOverrides): Promise<void>;

		"pause()"(overrides?: CallOverrides): Promise<void>;

		paused(overrides?: CallOverrides): Promise<boolean>;

		"paused()"(overrides?: CallOverrides): Promise<boolean>;

		predictEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

		"predictEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

		proofTokens(overrides?: CallOverrides): Promise<string>;

		"proofTokens()"(overrides?: CallOverrides): Promise<string>;

		redeemEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

		"redeemEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

		resolveEvent(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: CallOverrides): Promise<void>;

		"resolveEvent(uint256,uint256[])"(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: CallOverrides): Promise<void>;

		supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;

		"supportsInterface(bytes4)"(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;

		totalEvent(overrides?: CallOverrides): Promise<BigNumber>;

		"totalEvent()"(overrides?: CallOverrides): Promise<BigNumber>;

		unpause(overrides?: CallOverrides): Promise<void>;

		"unpause()"(overrides?: CallOverrides): Promise<void>;

		updateEntranceFee(_amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

		"updateEntranceFee(uint256)"(_amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

		updateFeeRecipient(_recepient: string, overrides?: CallOverrides): Promise<void>;

		"updateFeeRecipient(address)"(_recepient: string, overrides?: CallOverrides): Promise<void>;
	};

	filters: {
		AdditionalRewardEvent(eventId: BigNumberish | null, amount: null): EventFilter;

		CancelEvent(creator: string | null, eventId: null): EventFilter;

		CreatedEvent(
			eventId: BigNumberish | null,
			creator: string | null,
			description: null,
			_answers: null,
			payment: null,
			creatorFee: null,
			startTime: null,
			endTime: null,
			extraTime: null
		): EventFilter;

		Paused(account: null): EventFilter;

		PredictedEvent(predictor: string | null, eventId: BigNumberish | null, option: BigNumberish | null, amount: null): EventFilter;

		RedeemEvent(predictor: string | null, eventId: BigNumberish | null, option: BigNumberish | null, reward: null): EventFilter;

		ResolvedEvent(eventId: BigNumberish | null, creator: null, outcomes: null, creatorFee: null): EventFilter;

		Unpaused(account: null): EventFilter;
	};

	estimateGas: {
		INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

		"INVERSE_BASIS_POINT()"(overrides?: CallOverrides): Promise<BigNumber>;

		MAX_CREATOR_FEE(overrides?: CallOverrides): Promise<BigNumber>;

		"MAX_CREATOR_FEE()"(overrides?: CallOverrides): Promise<BigNumber>;

		SERVICE_FEE(overrides?: CallOverrides): Promise<BigNumber>;

		"SERVICE_FEE()"(overrides?: CallOverrides): Promise<BigNumber>;

		additionalRewardEvent(_eventId: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

		"additionalRewardEvent(uint256,uint256)"(_eventId: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

		cancelEvent(_eventId: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

		"cancelEvent(uint256)"(_eventId: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

		createEvent(
			_description: string,
			_answers: string[],
			_payment: string,
			_creatorFee: BigNumberish,
			_startTime: BigNumberish,
			_endTime: BigNumberish,
			_extraTime: BigNumberish,
			overrides?: PayableOverrides
		): Promise<BigNumber>;

		"createEvent(string,string[],address,uint256,uint256,uint256,uint256)"(
			_description: string,
			_answers: string[],
			_payment: string,
			_creatorFee: BigNumberish,
			_startTime: BigNumberish,
			_endTime: BigNumberish,
			_extraTime: BigNumberish,
			overrides?: PayableOverrides
		): Promise<BigNumber>;

		entranceFee(overrides?: CallOverrides): Promise<BigNumber>;

		"entranceFee()"(overrides?: CallOverrides): Promise<BigNumber>;

		eventDetail(_eventId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		"eventDetail(uint256)"(_eventId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		extraReward(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

		"extraReward(address)"(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

		feeRecipient(overrides?: CallOverrides): Promise<BigNumber>;

		"feeRecipient()"(overrides?: CallOverrides): Promise<BigNumber>;

		metaspacecyAccessControls(overrides?: CallOverrides): Promise<BigNumber>;

		"metaspacecyAccessControls()"(overrides?: CallOverrides): Promise<BigNumber>;

		onERC1155BatchReceived(arg0: string, arg1: string, arg2: BigNumberish[], arg3: BigNumberish[], arg4: BytesLike, overrides?: Overrides): Promise<BigNumber>;

		"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
			arg0: string,
			arg1: string,
			arg2: BigNumberish[],
			arg3: BigNumberish[],
			arg4: BytesLike,
			overrides?: Overrides
		): Promise<BigNumber>;

		onERC1155Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, overrides?: Overrides): Promise<BigNumber>;

		"onERC1155Received(address,address,uint256,uint256,bytes)"(arg0: string, arg1: string, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, overrides?: Overrides): Promise<BigNumber>;

		pause(overrides?: Overrides): Promise<BigNumber>;

		"pause()"(overrides?: Overrides): Promise<BigNumber>;

		paused(overrides?: CallOverrides): Promise<BigNumber>;

		"paused()"(overrides?: CallOverrides): Promise<BigNumber>;

		predictEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: PayableOverrides): Promise<BigNumber>;

		"predictEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: PayableOverrides): Promise<BigNumber>;

		proofTokens(overrides?: CallOverrides): Promise<BigNumber>;

		"proofTokens()"(overrides?: CallOverrides): Promise<BigNumber>;

		redeemEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

		"redeemEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

		resolveEvent(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: Overrides): Promise<BigNumber>;

		"resolveEvent(uint256,uint256[])"(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: Overrides): Promise<BigNumber>;

		supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

		"supportsInterface(bytes4)"(interfaceId: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

		totalEvent(overrides?: CallOverrides): Promise<BigNumber>;

		"totalEvent()"(overrides?: CallOverrides): Promise<BigNumber>;

		unpause(overrides?: Overrides): Promise<BigNumber>;

		"unpause()"(overrides?: Overrides): Promise<BigNumber>;

		updateEntranceFee(_amount: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

		"updateEntranceFee(uint256)"(_amount: BigNumberish, overrides?: Overrides): Promise<BigNumber>;

		updateFeeRecipient(_recepient: string, overrides?: Overrides): Promise<BigNumber>;

		"updateFeeRecipient(address)"(_recepient: string, overrides?: Overrides): Promise<BigNumber>;
	};

	populateTransaction: {
		INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"INVERSE_BASIS_POINT()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		MAX_CREATOR_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"MAX_CREATOR_FEE()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		SERVICE_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"SERVICE_FEE()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		additionalRewardEvent(_eventId: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<PopulatedTransaction>;

		"additionalRewardEvent(uint256,uint256)"(_eventId: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<PopulatedTransaction>;

		cancelEvent(_eventId: BigNumberish, overrides?: Overrides): Promise<PopulatedTransaction>;

		"cancelEvent(uint256)"(_eventId: BigNumberish, overrides?: Overrides): Promise<PopulatedTransaction>;

		createEvent(
			_description: string,
			_answers: string[],
			_payment: string,
			_creatorFee: BigNumberish,
			_startTime: BigNumberish,
			_endTime: BigNumberish,
			_extraTime: BigNumberish,
			overrides?: PayableOverrides
		): Promise<PopulatedTransaction>;

		"createEvent(string,string[],address,uint256,uint256,uint256,uint256)"(
			_description: string,
			_answers: string[],
			_payment: string,
			_creatorFee: BigNumberish,
			_startTime: BigNumberish,
			_endTime: BigNumberish,
			_extraTime: BigNumberish,
			overrides?: PayableOverrides
		): Promise<PopulatedTransaction>;

		entranceFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"entranceFee()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		eventDetail(_eventId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"eventDetail(uint256)"(_eventId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

		extraReward(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"extraReward(address)"(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

		feeRecipient(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"feeRecipient()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		metaspacecyAccessControls(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"metaspacecyAccessControls()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		onERC1155BatchReceived(arg0: string, arg1: string, arg2: BigNumberish[], arg3: BigNumberish[], arg4: BytesLike, overrides?: Overrides): Promise<PopulatedTransaction>;

		"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"(
			arg0: string,
			arg1: string,
			arg2: BigNumberish[],
			arg3: BigNumberish[],
			arg4: BytesLike,
			overrides?: Overrides
		): Promise<PopulatedTransaction>;

		onERC1155Received(arg0: string, arg1: string, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, overrides?: Overrides): Promise<PopulatedTransaction>;

		"onERC1155Received(address,address,uint256,uint256,bytes)"(
			arg0: string,
			arg1: string,
			arg2: BigNumberish,
			arg3: BigNumberish,
			arg4: BytesLike,
			overrides?: Overrides
		): Promise<PopulatedTransaction>;

		pause(overrides?: Overrides): Promise<PopulatedTransaction>;

		"pause()"(overrides?: Overrides): Promise<PopulatedTransaction>;

		paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"paused()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		predictEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: PayableOverrides): Promise<PopulatedTransaction>;

		"predictEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: PayableOverrides): Promise<PopulatedTransaction>;

		proofTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"proofTokens()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		redeemEvent(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<PopulatedTransaction>;

		"redeemEvent(uint256,uint256,uint256)"(_eventId: BigNumberish, _option: BigNumberish, _amount: BigNumberish, overrides?: Overrides): Promise<PopulatedTransaction>;

		resolveEvent(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: Overrides): Promise<PopulatedTransaction>;

		"resolveEvent(uint256,uint256[])"(_eventId: BigNumberish, _outcomes: BigNumberish[], overrides?: Overrides): Promise<PopulatedTransaction>;

		supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"supportsInterface(bytes4)"(interfaceId: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

		totalEvent(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		"totalEvent()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		unpause(overrides?: Overrides): Promise<PopulatedTransaction>;

		"unpause()"(overrides?: Overrides): Promise<PopulatedTransaction>;

		updateEntranceFee(_amount: BigNumberish, overrides?: Overrides): Promise<PopulatedTransaction>;

		"updateEntranceFee(uint256)"(_amount: BigNumberish, overrides?: Overrides): Promise<PopulatedTransaction>;

		updateFeeRecipient(_recepient: string, overrides?: Overrides): Promise<PopulatedTransaction>;

		"updateFeeRecipient(address)"(_recepient: string, overrides?: Overrides): Promise<PopulatedTransaction>;
	};
}

declare enum Network {
    bnbTestnet = 97,
    bnbMainnet = 56
}

declare type EventDetail = {
    description: string;
    answers: Array<string>;
    creator: string;
    payment: string;
    reward: BigNumber;
    creatorFee: number;
    startTime: number;
    endTime: number;
    extraTime: number;
    outcomes: Array<number>;
};
declare type CreatedEventOutput = Omit<EventDetail, "outcomes" | "reward"> & {
    eventId: number;
    txHash: string;
};
declare type PredictedEventOutput = {
    predictor: string;
    eventId: number;
    option: number;
    amount: BigNumber;
    txHash: string;
};
declare type ResolveEventOutput = {
    creator: string;
    eventId: number;
    outcomes: Array<number>;
    txHash: string;
};
declare type RedeemEventOutput = Omit<PredictedEventOutput, "">;
declare type CancelEventOutput = {
    creator: string;
    eventId: number;
    txHash: string;
};

declare type RegisterOperatorOutput = {
    operator: string;
    txHash: string;
};

declare class InformationSDK {
    contract: PredictionCollateral;
    private network;
    private provider;
    private signer?;
    constructor(providerOrSigner: providers.JsonRpcProvider | Signer, network: Network);
    /**
     * @return Amount fee native coin of network,that fee creator pay when want to create event.
     */
    getEntranceFee(): Promise<number>;
    /**
     * @returns Service fee percent will pay for protocol
     */
    getServiceFeePercent(): Promise<number>;
    /**
     * @returns Number events created
     */
    getTotalEvent(): Promise<number>;
    /**
     * @abstract get all parameter of a event.
     * @param eventId index of event, identifier for that event
     * @returns Detail of a event .
     */
    getEventDetail(eventId: number): Promise<EventDetail>;
    /**
     * @abstract Register permission to create event.
     */
    registerOperator(): Promise<RegisterOperatorOutput>;
    /**
     * @abstract create a event.
     * @param description a question about future events
     * @param answers answer for question
     * @param payment address token using to participant predict event
     * @param creatorFee fee percent pay for creator event
     * @param startTime start time event
     * @param endTime end time event
     * @param accountAddress specific sender transaction
     * @returns detail of event created .
     */
    createEvent(description: string, answers: Array<string>, payment: string, creatorFee: number, startTime: number, endTime: number, extraTime: number, accountAddress?: string): Promise<CreatedEventOutput>;
    /**
     * @abstract predict a event existed
     * @param eventId index of event, identifier for that event
     * @param option  index of array answers. Start with zero.
     * @param amount  amount token use to predict event
     * @param accountAddress specific sender transaction
     * @returns detail parameter predicted
     */
    predictEvent(eventId: number, option: number, amount: number, accountAddress?: string): Promise<PredictedEventOutput>;
    /**
     * @abstract creator set result of event
     * @param eventId index of event, identifier for that event
     * @param outcomes  array percent of options
     * @param accountAddress specific sender transaction
     * @returns detail parameter resolved
     */
    resolveEvent(eventId: number, outcomes: Array<number>, accountAddress?: string): Promise<ResolveEventOutput>;
    /**
     * @abstract user predicted will call to redeem reward if winner
     * @param eventId index of event, identifier for that event
     * @param option  option user predicted
     * @param amount amount user want redeem
     * @param accountAddress specific sender transaction
     * @returns detail parameter redeem
     */
    redeemEvent(eventId: number, option: number, amount: number, accountAddress?: string): Promise<RedeemEventOutput>;
    /**
     * @abstract creator can cancel event if event not started yet
     * @param eventId index of event, identifier for that event
     * @param accountAddress specific sender transaction
     * @returns detail parameter cancel
     */
    cancelEvent(eventId: number, accountAddress?: string): Promise<CancelEventOutput>;
    /**
     * @abstract only admin can change entrance fee
     * @param amount new amount entrance fee
     */
    updateEntranceFee(amount: BigNumber, accountAddress?: string): Promise<string>;
    getSigner(accountAddress?: string): Signer;
    private _getSigner;
    private _parseAmountToWei;
}

export { InformationSDK, Network };
